// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Polar.OpenAPI.Models
{
    /// <summary>
    /// Checkout session data retrieved using the client secret after confirmation.It contains a customer session token to retrieve order informationright after the checkout.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class CheckoutPublicConfirmed : IAdditionalDataHolder, IParsable
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Whether to allow the customer to apply discount codes. If you apply a discount through `discount_id`, it&apos;ll still be applied, but the customer won&apos;t be able to change it.</summary>
        public bool? AllowDiscountCodes { get; set; }
        /// <summary>Amount in cents, before discounts and taxes.</summary>
        public int? Amount { get; set; }
        /// <summary>The attached_custom_fields property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Polar.OpenAPI.Models.AttachedCustomField>? AttachedCustomFields { get; set; }
#nullable restore
#else
        public List<global::Polar.OpenAPI.Models.AttachedCustomField> AttachedCustomFields { get; set; }
#endif
        /// <summary>Client secret used to update and complete the checkout session from the client.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ClientSecret { get; set; }
#nullable restore
#else
        public string ClientSecret { get; set; }
#endif
        /// <summary>Creation timestamp of the object.</summary>
        public DateTimeOffset? CreatedAt { get; set; }
        /// <summary>Currency code of the checkout session.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency? Currency { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency Currency { get; set; }
#endif
        /// <summary>The customer_billing_address property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.Address? CustomerBillingAddress { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.Address CustomerBillingAddress { get; set; }
#endif
        /// <summary>Email address of the customer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email? CustomerEmail { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email CustomerEmail { get; set; }
#endif
        /// <summary>The customer_id property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id? CustomerId { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id CustomerId { get; set; }
#endif
        /// <summary>The customer_ip_address property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address? CustomerIpAddress { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address CustomerIpAddress { get; set; }
#endif
        /// <summary>Name of the customer.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name? CustomerName { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name CustomerName { get; set; }
#endif
        /// <summary>The customer_session_token property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? CustomerSessionToken { get; set; }
#nullable restore
#else
        public string CustomerSessionToken { get; set; }
#endif
        /// <summary>The customer_tax_id property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id? CustomerTaxId { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id CustomerTaxId { get; set; }
#endif
        /// <summary>Key-value object storing custom field values.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_custom_field_data? CustomFieldData { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_custom_field_data CustomFieldData { get; set; }
#endif
        /// <summary>The discount property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public UntypedNode? Discount { get; set; }
#nullable restore
#else
        public UntypedNode Discount { get; set; }
#endif
        /// <summary>Discount amount in cents.</summary>
        public int? DiscountAmount { get; set; }
        /// <summary>ID of the discount applied to the checkout.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id? DiscountId { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id DiscountId { get; set; }
#endif
        /// <summary>When checkout is embedded, represents the Origin of the page embedding the checkout. Used as a security measure to send messages only to the embedding page.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin? EmbedOrigin { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin EmbedOrigin { get; set; }
#endif
        /// <summary>Expiration date and time of the checkout session.</summary>
        public DateTimeOffset? ExpiresAt { get; set; }
        /// <summary>The ID of the object.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Id { get; set; }
#nullable restore
#else
        public string Id { get; set; }
#endif
        /// <summary>Whether the discount is applicable to the checkout. Typically, free and custom prices are not discountable.</summary>
        public bool? IsDiscountApplicable { get; set; }
        /// <summary>Whether the product price is free, regardless of discounts.</summary>
        public bool? IsFreeProductPrice { get; set; }
        /// <summary>Whether the checkout requires a payment form, whether because of a payment or payment method setup.</summary>
        public bool? IsPaymentFormRequired { get; set; }
        /// <summary>Whether the checkout requires payment, e.g. in case of free products or discounts that cover the total amount.</summary>
        public bool? IsPaymentRequired { get; set; }
        /// <summary>Whether the checkout requires setting up a payment method, regardless of the amount, e.g. subscriptions that have first free cycles.</summary>
        public bool? IsPaymentSetupRequired { get; set; }
        /// <summary>Last modification timestamp of the object.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at? ModifiedAt { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at ModifiedAt { get; set; }
#endif
        /// <summary>Amount in cents, after discounts but before taxes.</summary>
        public int? NetAmount { get; set; }
        /// <summary>The organization property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.Organization? Organization { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.Organization Organization { get; set; }
#endif
        /// <summary>Payment processor used.</summary>
        public global::Polar.OpenAPI.Models.PaymentProcessor? PaymentProcessor { get; set; }
        /// <summary>The payment_processor_metadata property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_payment_processor_metadata? PaymentProcessorMetadata { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_payment_processor_metadata PaymentProcessorMetadata { get; set; }
#endif
        /// <summary>Product selected to checkout.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutProduct? Product { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutProduct Product { get; set; }
#endif
        /// <summary>ID of the product to checkout.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProductId { get; set; }
#nullable restore
#else
        public string ProductId { get; set; }
#endif
        /// <summary>Price of the selected product.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price? ProductPrice { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price ProductPrice { get; set; }
#endif
        /// <summary>ID of the product price to checkout.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? ProductPriceId { get; set; }
#nullable restore
#else
        public string ProductPriceId { get; set; }
#endif
        /// <summary>List of products available to select.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Polar.OpenAPI.Models.CheckoutProduct>? Products { get; set; }
#nullable restore
#else
        public List<global::Polar.OpenAPI.Models.CheckoutProduct> Products { get; set; }
#endif
        /// <summary>The status property</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Status { get; set; }
#nullable restore
#else
        public string Status { get; set; }
#endif
        /// <summary>The subtotal_amount property</summary>
        [Obsolete("")]
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount? SubtotalAmount { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount SubtotalAmount { get; set; }
#endif
        /// <summary>URL where the customer will be redirected after a successful payment.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? SuccessUrl { get; set; }
#nullable restore
#else
        public string SuccessUrl { get; set; }
#endif
        /// <summary>Sales tax amount in cents. If `null`, it means there is no enough information yet to calculate it.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount? TaxAmount { get; set; }
#nullable restore
#else
        public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount TaxAmount { get; set; }
#endif
        /// <summary>Amount in cents, after discounts and taxes.</summary>
        public int? TotalAmount { get; set; }
        /// <summary>URL where the customer can access the checkout session.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Url { get; set; }
#nullable restore
#else
        public string Url { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed"/> and sets the default values.
        /// </summary>
        public CheckoutPublicConfirmed()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "allow_discount_codes", n => { AllowDiscountCodes = n.GetBoolValue(); } },
                { "amount", n => { Amount = n.GetIntValue(); } },
                { "attached_custom_fields", n => { AttachedCustomFields = n.GetCollectionOfObjectValues<global::Polar.OpenAPI.Models.AttachedCustomField>(global::Polar.OpenAPI.Models.AttachedCustomField.CreateFromDiscriminatorValue)?.AsList(); } },
                { "client_secret", n => { ClientSecret = n.GetStringValue(); } },
                { "created_at", n => { CreatedAt = n.GetDateTimeOffsetValue(); } },
                { "currency", n => { Currency = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency.CreateFromDiscriminatorValue); } },
                { "custom_field_data", n => { CustomFieldData = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_custom_field_data>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_custom_field_data.CreateFromDiscriminatorValue); } },
                { "customer_billing_address", n => { CustomerBillingAddress = n.GetObjectValue<global::Polar.OpenAPI.Models.Address>(global::Polar.OpenAPI.Models.Address.CreateFromDiscriminatorValue); } },
                { "customer_email", n => { CustomerEmail = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email.CreateFromDiscriminatorValue); } },
                { "customer_id", n => { CustomerId = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id.CreateFromDiscriminatorValue); } },
                { "customer_ip_address", n => { CustomerIpAddress = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address.CreateFromDiscriminatorValue); } },
                { "customer_name", n => { CustomerName = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name.CreateFromDiscriminatorValue); } },
                { "customer_session_token", n => { CustomerSessionToken = n.GetStringValue(); } },
                { "customer_tax_id", n => { CustomerTaxId = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id.CreateFromDiscriminatorValue); } },
                { "discount", n => { Discount = n.GetObjectValue<UntypedNode>(UntypedNode.CreateFromDiscriminatorValue); } },
                { "discount_amount", n => { DiscountAmount = n.GetIntValue(); } },
                { "discount_id", n => { DiscountId = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id.CreateFromDiscriminatorValue); } },
                { "embed_origin", n => { EmbedOrigin = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin.CreateFromDiscriminatorValue); } },
                { "expires_at", n => { ExpiresAt = n.GetDateTimeOffsetValue(); } },
                { "id", n => { Id = n.GetStringValue(); } },
                { "is_discount_applicable", n => { IsDiscountApplicable = n.GetBoolValue(); } },
                { "is_free_product_price", n => { IsFreeProductPrice = n.GetBoolValue(); } },
                { "is_payment_form_required", n => { IsPaymentFormRequired = n.GetBoolValue(); } },
                { "is_payment_required", n => { IsPaymentRequired = n.GetBoolValue(); } },
                { "is_payment_setup_required", n => { IsPaymentSetupRequired = n.GetBoolValue(); } },
                { "modified_at", n => { ModifiedAt = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at.CreateFromDiscriminatorValue); } },
                { "net_amount", n => { NetAmount = n.GetIntValue(); } },
                { "organization", n => { Organization = n.GetObjectValue<global::Polar.OpenAPI.Models.Organization>(global::Polar.OpenAPI.Models.Organization.CreateFromDiscriminatorValue); } },
                { "payment_processor", n => { PaymentProcessor = n.GetEnumValue<global::Polar.OpenAPI.Models.PaymentProcessor>(); } },
                { "payment_processor_metadata", n => { PaymentProcessorMetadata = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_payment_processor_metadata>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_payment_processor_metadata.CreateFromDiscriminatorValue); } },
                { "product", n => { Product = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutProduct>(global::Polar.OpenAPI.Models.CheckoutProduct.CreateFromDiscriminatorValue); } },
                { "product_id", n => { ProductId = n.GetStringValue(); } },
                { "product_price", n => { ProductPrice = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price.CreateFromDiscriminatorValue); } },
                { "product_price_id", n => { ProductPriceId = n.GetStringValue(); } },
                { "products", n => { Products = n.GetCollectionOfObjectValues<global::Polar.OpenAPI.Models.CheckoutProduct>(global::Polar.OpenAPI.Models.CheckoutProduct.CreateFromDiscriminatorValue)?.AsList(); } },
                { "status", n => { Status = n.GetStringValue(); } },
                { "subtotal_amount", n => { SubtotalAmount = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount.CreateFromDiscriminatorValue); } },
                { "success_url", n => { SuccessUrl = n.GetStringValue(); } },
                { "tax_amount", n => { TaxAmount = n.GetObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount>(global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount.CreateFromDiscriminatorValue); } },
                { "total_amount", n => { TotalAmount = n.GetIntValue(); } },
                { "url", n => { Url = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("allow_discount_codes", AllowDiscountCodes);
            writer.WriteIntValue("amount", Amount);
            writer.WriteCollectionOfObjectValues<global::Polar.OpenAPI.Models.AttachedCustomField>("attached_custom_fields", AttachedCustomFields);
            writer.WriteStringValue("client_secret", ClientSecret);
            writer.WriteDateTimeOffsetValue("created_at", CreatedAt);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency>("currency", Currency);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.Address>("customer_billing_address", CustomerBillingAddress);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email>("customer_email", CustomerEmail);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id>("customer_id", CustomerId);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address>("customer_ip_address", CustomerIpAddress);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name>("customer_name", CustomerName);
            writer.WriteStringValue("customer_session_token", CustomerSessionToken);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id>("customer_tax_id", CustomerTaxId);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_custom_field_data>("custom_field_data", CustomFieldData);
            writer.WriteObjectValue<UntypedNode>("discount", Discount);
            writer.WriteIntValue("discount_amount", DiscountAmount);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id>("discount_id", DiscountId);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin>("embed_origin", EmbedOrigin);
            writer.WriteDateTimeOffsetValue("expires_at", ExpiresAt);
            writer.WriteStringValue("id", Id);
            writer.WriteBoolValue("is_discount_applicable", IsDiscountApplicable);
            writer.WriteBoolValue("is_free_product_price", IsFreeProductPrice);
            writer.WriteBoolValue("is_payment_form_required", IsPaymentFormRequired);
            writer.WriteBoolValue("is_payment_required", IsPaymentRequired);
            writer.WriteBoolValue("is_payment_setup_required", IsPaymentSetupRequired);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at>("modified_at", ModifiedAt);
            writer.WriteIntValue("net_amount", NetAmount);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.Organization>("organization", Organization);
            writer.WriteEnumValue<global::Polar.OpenAPI.Models.PaymentProcessor>("payment_processor", PaymentProcessor);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_payment_processor_metadata>("payment_processor_metadata", PaymentProcessorMetadata);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutProduct>("product", Product);
            writer.WriteStringValue("product_id", ProductId);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price>("product_price", ProductPrice);
            writer.WriteStringValue("product_price_id", ProductPriceId);
            writer.WriteCollectionOfObjectValues<global::Polar.OpenAPI.Models.CheckoutProduct>("products", Products);
            writer.WriteStringValue("status", Status);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount>("subtotal_amount", SubtotalAmount);
            writer.WriteStringValue("success_url", SuccessUrl);
            writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount>("tax_amount", TaxAmount);
            writer.WriteIntValue("total_amount", TotalAmount);
            writer.WriteStringValue("url", Url);
            writer.WriteAdditionalData(AdditionalData);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_currency : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1? CheckoutPublicConfirmedCurrencyMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1 CheckoutPublicConfirmedCurrencyMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_currency();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCurrencyMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCurrencyMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCurrencyMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_currencyMember1>(null, CheckoutPublicConfirmedCurrencyMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_customer_email : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1? CheckoutPublicConfirmedCustomerEmailMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1 CheckoutPublicConfirmedCustomerEmailMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_email();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCustomerEmailMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCustomerEmailMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCustomerEmailMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_emailMember1>(null, CheckoutPublicConfirmedCustomerEmailMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_customer_id : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1? CheckoutPublicConfirmedCustomerIdMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1 CheckoutPublicConfirmedCustomerIdMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_id();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCustomerIdMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCustomerIdMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCustomerIdMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_idMember1>(null, CheckoutPublicConfirmedCustomerIdMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_customer_ip_address : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1? CheckoutPublicConfirmedCustomerIpAddressMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1 CheckoutPublicConfirmedCustomerIpAddressMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_ip_address();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCustomerIpAddressMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCustomerIpAddressMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCustomerIpAddressMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_ip_addressMember1>(null, CheckoutPublicConfirmedCustomerIpAddressMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_customer_name : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1? CheckoutPublicConfirmedCustomerNameMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1 CheckoutPublicConfirmedCustomerNameMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_name();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCustomerNameMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCustomerNameMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCustomerNameMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_nameMember1>(null, CheckoutPublicConfirmedCustomerNameMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_customer_tax_id : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1? CheckoutPublicConfirmedCustomerTaxIdMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1 CheckoutPublicConfirmedCustomerTaxIdMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_customer_tax_id();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedCustomerTaxIdMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedCustomerTaxIdMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedCustomerTaxIdMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_customer_tax_idMember1>(null, CheckoutPublicConfirmedCustomerTaxIdMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_discount_id : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1? CheckoutPublicConfirmedDiscountIdMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1 CheckoutPublicConfirmedDiscountIdMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_discount_id();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedDiscountIdMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedDiscountIdMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedDiscountIdMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_discount_idMember1>(null, CheckoutPublicConfirmedDiscountIdMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_embed_origin : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1? CheckoutPublicConfirmedEmbedOriginMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1 CheckoutPublicConfirmedEmbedOriginMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_embed_origin();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.CheckoutPublicConfirmedEmbedOriginMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedEmbedOriginMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedEmbedOriginMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_embed_originMember1>(null, CheckoutPublicConfirmedEmbedOriginMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="DateTimeOffset"/>, <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_modified_at : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1? CheckoutPublicConfirmedModifiedAtMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1 CheckoutPublicConfirmedModifiedAtMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="DateTimeOffset"/></summary>
            public DateTimeOffset? DateTimeOffset { get; set; }
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_modified_at();
                if(parseNode.GetDateTimeOffsetValue() is DateTimeOffset dateTimeOffsetValue)
                {
                    result.DateTimeOffset = dateTimeOffsetValue;
                }
                else {
                    result.CheckoutPublicConfirmedModifiedAtMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedModifiedAtMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedModifiedAtMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(DateTimeOffset != null)
                {
                    writer.WriteDateTimeOffsetValue(null, DateTimeOffset);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_modified_atMember1>(null, CheckoutPublicConfirmedModifiedAtMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.LegacyRecurringProductPrice"/>, <see cref="global::Polar.OpenAPI.Models.ProductPrice"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_product_price : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.LegacyRecurringProductPrice"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.LegacyRecurringProductPrice? LegacyRecurringProductPrice { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.LegacyRecurringProductPrice LegacyRecurringProductPrice { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.ProductPrice"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.ProductPrice? ProductPrice { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.ProductPrice ProductPrice { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var mappingValue = parseNode.GetChildNode("amount_type")?.GetStringValue();
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_product_price();
                if("".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.LegacyRecurringProductPrice = new global::Polar.OpenAPI.Models.LegacyRecurringProductPrice();
                }
                else if("".Equals(mappingValue, StringComparison.OrdinalIgnoreCase))
                {
                    result.ProductPrice = new global::Polar.OpenAPI.Models.ProductPrice();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(LegacyRecurringProductPrice != null)
                {
                    return LegacyRecurringProductPrice.GetFieldDeserializers();
                }
                else if(ProductPrice != null)
                {
                    return ProductPrice.GetFieldDeserializers();
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(LegacyRecurringProductPrice != null)
                {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.LegacyRecurringProductPrice>(null, LegacyRecurringProductPrice);
                }
                else if(ProductPrice != null)
                {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.ProductPrice>(null, ProductPrice);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1"/>, <see cref="int"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_subtotal_amount : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1? CheckoutPublicConfirmedSubtotalAmountMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1 CheckoutPublicConfirmedSubtotalAmountMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="int"/></summary>
            public int? Integer { get; set; }
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_subtotal_amount();
                if(parseNode.GetIntValue() is int integerValue)
                {
                    result.Integer = integerValue;
                }
                else {
                    result.CheckoutPublicConfirmedSubtotalAmountMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedSubtotalAmountMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedSubtotalAmountMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(Integer != null)
                {
                    writer.WriteIntValue(null, Integer);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_subtotal_amountMember1>(null, CheckoutPublicConfirmedSubtotalAmountMember1);
                }
            }
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1"/>, <see cref="int"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class CheckoutPublicConfirmed_tax_amount : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1? CheckoutPublicConfirmedTaxAmountMember1 { get; set; }
#nullable restore
#else
            public global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1 CheckoutPublicConfirmedTaxAmountMember1 { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="int"/></summary>
            public int? Integer { get; set; }
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed.CheckoutPublicConfirmed_tax_amount();
                if(parseNode.GetIntValue() is int integerValue)
                {
                    result.Integer = integerValue;
                }
                else {
                    result.CheckoutPublicConfirmedTaxAmountMember1 = new global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(CheckoutPublicConfirmedTaxAmountMember1 != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(CheckoutPublicConfirmedTaxAmountMember1);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(Integer != null)
                {
                    writer.WriteIntValue(null, Integer);
                }
                else {
                    writer.WriteObjectValue<global::Polar.OpenAPI.Models.CheckoutPublicConfirmed_tax_amountMember1>(null, CheckoutPublicConfirmedTaxAmountMember1);
                }
            }
        }
    }
}
#pragma warning restore CS0618
